(* Copyright 2019 TEEX *)
(* Licensed under the Apache License, Version 2.0 (the "License"); *)
(* you may not use this file except in compliance with the License. *)
(* You may obtain a copy of the License at *)
(*    http://www.apache.org/licenses/LICENSE-2.0 *)
(* Unless required by applicable law or agreed to in writing, software *)
(* distributed under the License is distributed on an "AS IS" BASIS, *)
(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *)
(* See the License for the specific language governing permissions and *)
(* limitations under the License. *)

scilla_version 0


(***************************************************)
(*               Associated library                *)
(***************************************************)
library Oracle

(* OracleNode address owner_address pk status *)
type OracleNode =
| OracleNode of ByStr20 ByStr20 ByStr33 Uint32

(* Request ID from user_addr type paramHash gasPrice gasLimit fee callbackFunc ifResponded *)
type Request =
| Request of Uint32 ByStr20 ByStr20 Uint32 ByStr32 Uint128 Uint128 Uint128 String Uint32

(* Constant value *)
(* one node temporarily, may more nodes later on *)
let master_tee_address = 0xa391Fb22Ef65D65167A0c94D5E9b6eACece56c7E

let transfer_gas = Uint128 1
let withdraw_gas = Uint128 1000
let transfer_gas_price = Uint128 1000000000
let withdraw_gas_price = Uint128 1000000000
let min_fee = Uint128 1000000000000

let one_msg =
  fun (msg: Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* node status library *)
let init_status = Uint32 0
let stop_status = Uint32 2
let run_status = Uint32 3


(* error codes library *)
let code_success = Uint32 0
let code_node_not_found = Uint32 1
let code_request_not_found = Uint32 2
let code_reward_not_found = Uint32 3

let code_not_responded = Uint32 0
let code_is_responded = Uint32 1

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract Oracle
(owner: ByStr20)

(*             The fields definition               *)
field node_map: Map ByStr20 OracleNode = Emp ByStr20 OracleNode

field req_map: Map Uint32 Request = Emp Uint32 Request
field req_count: Uint32 = Uint32 0

(* oracle owner address <-> reward money *)
field reward_map: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(*             Register a node on chain            *)
transition register(owner_address : ByStr20, pk : ByStr33, proof : ByStr64)
    signed_str = builtin concat owner_address pk;
    signed_str_by_str = builtin to_bystr signed_str;
    legal = True;
    match legal with
    | True =>
        new_node = OracleNode _sender owner_address pk run_status;
        node_map[_sender] := new_node;
        e = {_eventname: "register"; msg: "register success"};
        event e
    | False =>
    end
end

(*             The node shut down                  *)
transition leave()
    nodes <- node_map;
    node_opt = builtin get nodes _sender;
    match node_opt with
    | None =>
        (* node is not found in the records *)
        msg = {_tag: "";
                _recipient: _sender;
                _amount: Uint128 0;
                code: code_node_not_found};
        msgs = one_msg msg;
        send msgs
    | Some (OracleNode address owner_address pk status) =>
        new_node = OracleNode _sender owner_address pk stop_status;
        node_map[_sender] := new_node;
        e = {_eventname: "leave"; msg: "node leave"};
        event e
    end
end

(*             The node come back                  *)
transition comeback()
    nodes <- node_map;
    node_opt = builtin get nodes _sender;
    match node_opt with
    | None =>
        (* node is not found in the records *)
        msg = {_tag: "";
                _recipient: _sender;
                _amount: Uint128 0;
                code: code_node_not_found};
        msgs = one_msg msg;
        send msgs
    | Some (OracleNode address owner_address pk status) =>
        new_node = OracleNode _sender owner_address pk run_status;
        node_map[_sender] := new_node;
        e = {_eventname: "comeback"; msg: "node come back"};
        event e
    end
end

(*             Send a request on chain             *)
transition request (user_addr : ByStr20, request_type : Uint32, param_data : String, gas_price : Uint128, gas_limit : Uint128, callback_func : String)
    gas_fee = builtin mul gas_price gas_limit;
    withdraw_fee = builtin mul withdraw_gas_price withdraw_gas;
    transfer_fee = builtin mul transfer_gas_price transfer_gas;
    total_fee = builtin add gas_fee withdraw_fee;
    total_fee = builtin add total_fee transfer_fee;
    check = builtin lt _amount total_fee;
    match check with
    |True =>
        e = {_eventname: "Not enough money"; msg: "fail request"};
        event e
    |False =>
        (* log the request *)
        id <- req_count;
        param_hash = builtin keccak256hash param_data;
        fee = builtin sub _amount total_fee;
        check_fee = builtin lt fee min_fee;
        match check_fee with
        |True =>
            e = {_eventname: "Not enough money"; msg: "fail request"};
            event e
        |False =>
            (* send the money to the master tee address *)
            accept;
            msg = { _tag : ""; _recipient : master_tee_address; _amount : _amount};
            msgs = one_msg msg;
            send msgs;
            new_req = Request id _sender user_addr request_type param_hash gas_price gas_limit fee callback_func code_not_responded;
            req_map[id] := new_req;
            e = {_eventname: "request"; msg: "send request success"; id: id; from: user_addr; reqtype: request_type; gaslimit: gas_limit; gasprice: gas_price; paramdata: param_data; fee: fee};
            event e;
            id =
            let x = Uint32 1 in builtin add x id;
            req_count := id
         end
     end
end

(*             Return the String type result       *)
transition responseString(id : Uint32, result : String, oracle_owner_address : ByStr20)
        requests <- req_map;
        request_opt = builtin get requests id;
        match request_opt with
        | None =>
            (* request is not found in the records *)
            e = {_eventname: "response fail"; msg : "the request id is not found"};
            event e
        | Some (Request id from user_addr request_type param_hash gas_price gas_limit fee callback_func if_responded) =>
            check_not_responded = builtin eq if_responded code_not_responded;
            match check_not_responded with
            | True =>
                (* set is_responded *)
                update_req = Request id from user_addr request_type param_hash gas_price gas_limit fee callback_func code_is_responded;
                req_map[id] := update_req;
                (* record the reward *)
                c_reward_map <- reward_map;
                check_have_reward = builtin get c_reward_map oracle_owner_address;
                match check_have_reward with
                | Some (history_reward) =>
                    new_reward = builtin add history_reward fee;
                    reward_map[oracle_owner_address] := new_reward
                | None =>
                    new_reward = fee;
                    reward_map[oracle_owner_address] := new_reward
                end;
                msg = { _tag : callback_func; _recipient : from; _amount : Uint128 0; result : result};
                msgs = one_msg msg;
                send msgs
            | False =>
                e = {_eventname: "repeat response"; msg: "have a response"};
                event e
            end
        end
end

(* The master tee checks how much money the oracle node has *)
transition get_reward_balance(oracle_owner_address : ByStr20)
    balance <- reward_map[oracle_owner_address];
    e = {_eventname: "reward_balance"; msg: balance};
    event e
end

(* The master tee calls to transfer reward to the oracle *)
transition withdraw_reward(oracle_owner_address : ByStr20)
    check_sender = builtin eq _sender master_tee_address;
    match check_sender with
    | True =>
        money = _amount;
        c_reward_map <- reward_map;
        check_have_reward = builtin get c_reward_map oracle_owner_address;
        match check_have_reward with
        | Some (balance) =>
            check_balance = builtin lt balance money;
            match check_balance with
            | False =>
                accept;
                (* send the money to the oracle *)
                msg = { _tag : ""; _recipient : oracle_owner_address; _amount : money};
                msgs = one_msg msg;
                send msgs;
                (* update the reward record *)
                new_balance = builtin sub balance money;
                reward_map[oracle_owner_address] := new_balance;
                e = {_eventname: "withdraw"; msg: "withdraw success"};
                event e
            | True =>
            end
        | None =>
        end
    | False =>
        e = {_eventname: "withdraw error"; msg: "No authority"};
        event e
     end
end

(* Copyright 2019 TEEX *)
(* Licensed under the Apache License, Version 2.0 (the "License"); *)
(* you may not use this file except in compliance with the License. *)
(* You may obtain a copy of the License at *)
(*    http://www.apache.org/licenses/LICENSE-2.0 *)
(* Unless required by applicable law or agreed to in writing, software *)
(* distributed under the License is distributed on an "AS IS" BASIS, *)
(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *)
(* See the License for the specific language governing permissions and *)
(* limitations under the License. *)

scilla_version 0


(***************************************************)
(*               Associated library                *)
(***************************************************)
library Oracle

(* OracleNode address owner_address pk status *)
type OracleNode =
| OracleNode of ByStr20 ByStr20 ByStr33 Uint32

(* Request ID from user_addr type paramData gasPrice gasLimit fee callbackFunc ifResponded *)
(* request type 0-builtin 1-webapi 2-swap_verify 3-cross chain info*)
type Request =
| Request of Uint32 ByStr20 ByStr20 Uint32 String Uint128 Uint128 Uint128 String Uint32

(* SwapRequest ID verifyId initialAddr swapChain initialMoney swapMoney targetAddr chainBInitialAddr chainBTargetAddr state allocator timeLock appealDdl*)
(* state 0-created 1-allocated 2-to_verified 3-finished *)
type SwapRequest =
| SwapRequest of Uint32 Uint32 ByStr20 String Uint128 Uint128 ByStr20 ByStr20 ByStr20 Uint32 ByStr20 BNum BNum

(* Stake from_addr money accumulatedStake*)
type Stake =
| Stake of ByStr20 Uint128 Uint128

(* Constant value *)
(* one node temporarily, may more nodes later on *)
let master_tee_address = 0x0105acd2cf6d016ecb85cf37fa8f1941c69f0017

let transfer_gas = Uint128 1
let withdraw_gas = Uint128 1000
let transfer_gas_price = Uint128 1000000000
let withdraw_gas_price = Uint128 1000000000
let min_fee = Uint128 1000000000000

let one_msg =
  fun (msg: Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* node status library *)
let init_status = Uint32 0
let stop_status = Uint32 2
let run_status = Uint32 3


(* error codes library *)
let code_success = Uint32 0
let code_node_not_found = Uint32 1
let code_request_not_found = Uint32 2
let code_reward_not_found = Uint32 3

let code_not_responded = Uint32 0
let code_is_responded = Uint32 1

(* swap params*)
let oracle_node_stake = Uint128 1000000000

(* swap states*)
let swap_created = Uint32 0
let swap_to_verified = Uint32 1
let swap_allocated = Uint32 2
let swap_finished = Uint32 3

let swap_lock = Uint32 2000
let appeal_time = Uint32 1000

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract Oracle
(owner: ByStr20)

(*             The fields definition               *)
field node_map: Map ByStr20 OracleNode = Emp ByStr20 OracleNode

field req_map: Map Uint32 Request = Emp Uint32 Request
field req_count: Uint32 = Uint32 0

(* oracle owner address <-> reward money *)
field reward_map: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* swap fields*)
field swap_req_map: Map Uint32 SwapRequest = Emp Uint32 SwapRequest
field swap_req_count: Uint32 = Uint32 0
(* verify request id <-> swap request id *)
field swap_verify_id_map: Map Uint32 Uint32 = Emp Uint32 Uint32
(* request id <-> stake *)
field stake_map: Map Uint32 Stake = Emp Uint32 Stake

(*             Register a node on chain            *)
transition register(owner_address : ByStr20, pk : ByStr33, proof : ByStr64)
    signed_str = builtin concat owner_address pk;
    signed_str_by_str = builtin to_bystr signed_str;
    legal = True;
    match legal with
    | True =>
        new_node = OracleNode _sender owner_address pk run_status;
        node_map[_sender] := new_node;
        e = {_eventname: "register"; msg: "register success"};
        event e
    | False =>
    end
end

(*             The node shut down                  *)
transition leave()
    nodes <- node_map;
    node_opt = builtin get nodes _sender;
    match node_opt with
    | None =>
        (* node is not found in the records *)
        msg = {_tag: "";
                _recipient: _sender;
                _amount: Uint128 0;
                code: code_node_not_found};
        msgs = one_msg msg;
        send msgs
    | Some (OracleNode address owner_address pk status) =>
        new_node = OracleNode _sender owner_address pk stop_status;
        node_map[_sender] := new_node;
        e = {_eventname: "leave"; msg: "node leave"};
        event e
    end
end

(*             The node come back                  *)
transition comeback()
    nodes <- node_map;
    node_opt = builtin get nodes _sender;
    match node_opt with
    | None =>
        (* node is not found in the records *)
        msg = {_tag: "";
                _recipient: _sender;
                _amount: Uint128 0;
                code: code_node_not_found};
        msgs = one_msg msg;
        send msgs
    | Some (OracleNode address owner_address pk status) =>
        new_node = OracleNode _sender owner_address pk run_status;
        node_map[_sender] := new_node;
        e = {_eventname: "comeback"; msg: "node come back"};
        event e
    end
end

(*             Send a request on chain             *)
transition request (user_addr : ByStr20, request_type : Uint32, param_data : String, gas_price : Uint128, gas_limit : Uint128, callback_func : String)
    gas_fee = builtin mul gas_price gas_limit;
    withdraw_fee = builtin mul withdraw_gas_price withdraw_gas;
    transfer_fee = builtin mul transfer_gas_price transfer_gas;
    total_fee = builtin add gas_fee withdraw_fee;
    total_fee = builtin add total_fee transfer_fee;
    check = builtin lt _amount total_fee;
    match check with
    |True =>
        e = {_eventname: "Not enough money"; msg: "fail request"};
        event e
    |False =>
        (* log the request *)
        id <- req_count;
        fee = builtin sub _amount total_fee;
        check_fee = builtin lt fee min_fee;
        match check_fee with
        |True =>
            e = {_eventname: "Not enough money"; msg: "fail request"};
            event e
        |False =>
            (* send the money to the master tee address *)
            accept;
            msg = { _tag : ""; _recipient : master_tee_address; _amount : _amount};
            msgs = one_msg msg;
            send msgs;
            new_req = Request id _sender user_addr request_type param_data gas_price gas_limit fee callback_func code_not_responded;
            req_map[id] := new_req;
            e = {_eventname: "request"; msg: "send request success"; id: id; from: user_addr; reqtype: request_type; gaslimit: gas_limit; gasprice: gas_price; paramdata: param_data; fee: fee};
            event e;
            id =
            let x = Uint32 1 in builtin add x id;
            req_count := id
         end
     end
end

(*             Return the String type result       *)
transition responseString(id : Uint32, result : String, oracle_owner_address : ByStr20)
        requests <- req_map;
        request_opt = builtin get requests id;
        match request_opt with
        | None =>
            (* request is not found in the records *)
            e = {_eventname: "response fail"; msg : "the request id is not found"};
            event e
        | Some (Request id from user_addr request_type param_data gas_price gas_limit fee callback_func if_responded) =>
            check_not_responded = builtin eq if_responded code_not_responded;
            match check_not_responded with
            | True =>
                (* set is_responded *)
                update_req = Request id from user_addr request_type param_data gas_price gas_limit fee callback_func code_is_responded;
                req_map[id] := update_req;
                (* record the reward *)
                c_reward_map <- reward_map;
                check_have_reward = builtin get c_reward_map oracle_owner_address;
                match check_have_reward with
                | Some (history_reward) =>
                    new_reward = builtin add history_reward fee;
                    reward_map[oracle_owner_address] := new_reward
                | None =>
                    new_reward = fee;
                    reward_map[oracle_owner_address] := new_reward
                end;
                msg = { _tag : callback_func; _recipient : from; _amount : Uint128 0; result : result};
                msgs = one_msg msg;
                send msgs
            | False =>
                e = {_eventname: "repeat response"; msg: "have a response"};
                event e
            end
        end
end

(* The master tee checks how much money the oracle node has *)
transition get_reward_balance(oracle_owner_address : ByStr20)
    balance <- reward_map[oracle_owner_address];
    e = {_eventname: "reward_balance"; msg: balance};
    event e
end

(* The master tee calls to transfer reward to the oracle *)
transition withdraw_reward(oracle_owner_address : ByStr20)
    check_sender = builtin eq _sender master_tee_address;
    match check_sender with
    | True =>
        money = _amount;
        c_reward_map <- reward_map;
        check_have_reward = builtin get c_reward_map oracle_owner_address;
        match check_have_reward with
        | Some (balance) =>
            check_balance = builtin lt balance money;
            match check_balance with
            | False =>
                accept;
                (* send the money to the oracle *)
                msg = { _tag : ""; _recipient : oracle_owner_address; _amount : money};
                msgs = one_msg msg;
                send msgs;
                (* update the reward record *)
                new_balance = builtin sub balance money;
                reward_map[oracle_owner_address] := new_balance;
                e = {_eventname: "withdraw"; msg: "withdraw success"};
                event e
            | True =>
            end
        | None =>
        end
    | False =>
        e = {_eventname: "withdraw error"; msg: "No authority"};
        event e
     end
end

transition request_swap(swap_chain: String, initial_money: Uint128, swap_money: Uint128, target_addr: ByStr20, swap_chain_initial_addr: ByStr20, swap_chain_target_addr: ByStr20)
    (* check the _amount *)
    check = builtin lt _amount initial_money;
    match check with
    |True =>
        e = {_eventname: "Not enough money"; msg: "fail request"};
        event e
    |False =>
        accept;
        (* set the time_lock and appeal_ddl *)
        cur_block_num <- & BLOCKNUMBER;
        time_lock = builtin badd cur_block_num swap_lock;
        appeal_ddl = builtin badd cur_block_num appeal_time;
        allocator = 0x0000000000000000000000000000000000000000;
        verify_id = Uint32 0;
        (* log the request *)
        id <- swap_req_count;
        new_req = SwapRequest id verify_id _sender swap_chain initial_money swap_money target_addr swap_chain_initial_addr swap_chain_target_addr swap_created allocator time_lock appeal_ddl;
        swap_req_map[id] := new_req;
        (* publish the event *)
        e = {_eventname: "swap"; msg: "New swap request"; id: id; initialaddr: _sender; swapchain: swap_chain; initialmoney: initial_money; swapmoney: swap_money; targetaddr: target_addr; swapchaininitialaddr: swap_chain_initial_addr; swapchaintargetaddr: swap_chain_target_addr};
        event e;
        id =
            let x = Uint32 1 in builtin add x id;
        swap_req_count := id
     end
end

transition commit_swap_hash(swap_request_id: Uint32, user_addr : ByStr20, tx_hash : String, gas_price : Uint128, gas_limit : Uint128)
    requests <- swap_req_map;
    request_opt = builtin get requests swap_request_id;
    match request_opt with
    | None =>
        (* check the swap request id *)
        e = {_eventname: "response fail"; msg : "the request id is not found"};
        event e
    | Some (SwapRequest swap_id verify_id initial_addr swap_chain initial_money swap_money target_addr swap_chain_initial_addr swap_chain_target_addr state allocator time_lock appeal_ddl) =>
        check_target_addr = builtin eq target_addr _sender;
        match check_target_addr with
        | False =>
            e = {_eventname: "appeal fail"; msg : "not the target addr"};
            event e
        | True =>
            gas_fee = builtin mul gas_price gas_limit;
            withdraw_fee = builtin mul withdraw_gas_price withdraw_gas;
            transfer_fee = builtin mul transfer_gas_price transfer_gas;
            total_fee = builtin add gas_fee withdraw_fee;
            total_fee = builtin add total_fee transfer_fee;
            check = builtin lt _amount total_fee;
            match check with
            |True =>
                e = {_eventname: "Not enough money"; msg: "fail request"};
                event e
            |False =>
                fee = builtin sub _amount total_fee;
                check_fee = builtin lt fee min_fee;
                match check_fee with
                |True =>
                    e = {_eventname: "Not enough money"; msg: "fail request"};
                    event e
                |False =>
                    (* send the money to the master tee address *)
                    accept;
                    msg = { _tag : ""; _recipient : master_tee_address; _amount : _amount};
                    msgs = one_msg msg;
                    send msgs;
                    callback_func = "";
                    (* verify request type *)
                    request_type = Uint32 2;
                    (* log the request *)
                    id <- req_count;
                    param_data = tx_hash;
                    new_req = Request id _sender user_addr request_type param_data gas_price gas_limit fee callback_func code_not_responded;
                    req_map[id] := new_req;
                    e = {_eventname: "verifyrequest"; msg: "send request success"; id: id; from: user_addr; reqtype: request_type; gaslimit: gas_limit; gasprice: gas_price; swapid: swap_id; swapchain: swap_chain; txhash: tx_hash; initialaddr: swap_chain_initial_addr; targetaddr: swap_chain_initial_addr; swapmoney: swap_money; fee: fee};
                    event e;
                    updated_swap_request = SwapRequest swap_id id initial_addr swap_chain initial_money swap_money target_addr swap_chain_initial_addr swap_chain_target_addr swap_to_verified allocator time_lock appeal_ddl;
                    swap_req_map[swap_id] := updated_swap_request;
                    (* bind the request id with the swap request id *)
                    swap_verify_id_map[id] := swap_request_id;
                    id =
                    let x = Uint32 1 in builtin add x id;
                    req_count := id
                 end
             end
        end
    end
end

transition register_to_process(verify_request_id : Uint32)
    (* check the stake *)
    stake_check = builtin lt _amount oracle_node_stake;
    match stake_check with
    |True =>
        e = {_eventname: "Not enough stake"; msg: "can't process"};
        event e
    |False =>
        request_id_map <- swap_verify_id_map;
        id_opt = builtin get request_id_map verify_request_id;
        match id_opt with
        | None =>
            (* request is not found in the records *)
            e = {_eventname: "register fail"; msg : "the request id is not found"};
            event e
        | Some(swap_request_id) =>
            requests <- swap_req_map;
            request_opt = builtin get requests swap_request_id;
            match request_opt with
            | None =>
                (* request is not found in the records *)
                e = {_eventname: "register fail"; msg : "the request id is not found"};
                event e
            | Some (SwapRequest swap_id verify_id initial_addr swap_chain initial_money swap_money target_addr swap_chain_initial_addr swap_chain_target_addr state allocator time_lock appeal_ddl) =>
                (* check the request if allocated *)
                if_allocated = builtin eq state swap_allocated;
                match if_allocated with
                |True =>
                    e = {_eventname: "register fail"; msg: "have allocated"};
                    event e
                |False =>
                    accept;
                    (* save the stake info *)
                    stakes <- stake_map;
                    stake_opt = builtin get stakes verify_id;
                    match stake_opt with
                    | None =>
                        accumulated_stake = Uint128 0;
                        new_stake = Stake _sender _amount accumulated_stake;
                        stake_map[verify_request_id] := new_stake
                    | Some (Stake from_addr money accumulated_stake) =>
                        update_stake = Stake _sender _amount accumulated_stake;
                        stake_map[verify_request_id] := update_stake
                    end;
                    (* set the request_state to isAllocated *)
                    update_req = SwapRequest swap_id verify_id initial_addr swap_chain initial_money swap_money target_addr swap_chain_initial_addr swap_chain_target_addr swap_allocated _sender time_lock appeal_ddl;
                    swap_req_map[swap_id] := update_req;
                    (* publish the event *)
                    e = {_eventname: "register success"; requestid: verify_request_id; to_node_addr: _sender };
                    event e
                end
            end
        end
    end
end

transition commit_verify_result(verify_request_id: Uint32, result: Bool, oracle_owner_address : ByStr20)
    (* result = 0 true  result = 1 false *)
    requests <- req_map;
    request_opt = builtin get requests verify_request_id;
    match request_opt with
    | None =>
        (* check if have the verify_request_id *)
        e = {_eventname: "response fail"; msg : "the request id is not found or it may be responded"};
        event e
    | Some (Request id from user_addr request_type param_data gas_price gas_limit fee callback_func if_responded) =>
        request_id_map <- swap_verify_id_map;
        id_opt = builtin get request_id_map verify_request_id;
        match id_opt with
        | None =>
            (* check if have the swap_request_id *)
            e = {_eventname: "response fail"; msg : "the request id is not found"};
            event e
        | Some(swap_request_id) =>
            swap_requests <- swap_req_map;
            swap_request_opt = builtin get swap_requests swap_request_id;
            match swap_request_opt with
            | None =>
                (* request is not found in the records *)
                e = {_eventname: "response fail"; msg : "the request id is not found"};
                event e
            | Some (SwapRequest swap_id verify_id initial_addr swap_chain initial_money swap_money target_addr swap_chain_initial_addr swap_chain_target_addr state allocator time_lock appeal_ddl) =>
                (* check if the sender is the allocator *)
                allocator_check = builtin eq _sender allocator;
                match allocator_check with
                |False =>
                    e = {_eventname: "response fail"; msg : "not be allocated"};
                    event e
                |True =>
                    stakes <- stake_map;
                    stake_opt = builtin get stakes verify_request_id;
                    match stake_opt with
                    | None =>
                    | Some (Stake from_addr money accumulated_stake) =>
                        check_responder = builtin eq from_addr _sender;
                        match check_responder with
                        |False =>
                            e = {_eventname: "response fail"; msg : "the verify request is appealed"};
                            event e
                        |True  =>
                            match result with
                            | False =>
                                (* return the lock swap money *)
                                msg = { _tag : ""; _recipient : initial_addr; _amount : initial_money};
                                msgs = one_msg msg;
                                send msgs
                            | True =>
                                (* transfer the swap money and the appeal money - accumulated_stake*)
                                temp_swap_money = builtin add initial_money accumulated_stake;
                                msg = { _tag : ""; _recipient : target_addr; _amount: temp_swap_money};
                                msgs = one_msg msg;
                                send msgs
                            end;
                            (* record the reward *)
                            c_reward_map <- reward_map;
                            check_have_reward = builtin get c_reward_map oracle_owner_address;
                            match check_have_reward with
                            | Some (history_reward) =>
                                new_reward = builtin add history_reward fee;
                                (* return the stake together *)
                                new_reward = builtin add new_reward money;
                                reward_map[oracle_owner_address] := new_reward
                            | None =>
                                new_reward = builtin add fee money;
                                reward_map[oracle_owner_address] := new_reward
                            end;
                            (* set the state to finished *)
                            update_req = SwapRequest swap_id verify_id initial_addr swap_chain initial_money swap_money target_addr swap_chain_initial_addr swap_chain_target_addr swap_finished allocator time_lock appeal_ddl;
                            swap_req_map[id] := update_req;
                            delete req_map[verify_request_id];
                            (* event for userA and userB to confirm the swap success *)
                            e = {_eventname: "Swap success"; initialaddr: initial_addr; swapchain: swap_chain; initialmoney: initial_money; swapmoney: swap_money; targetaddr: target_addr};
                            event e
                        end
                    end
                end
            end
        end
    end
end

transition appeal(swap_request_id: Uint32)
    swap_requests <- swap_req_map;
    swap_request_opt = builtin get swap_requests swap_request_id;
    match swap_request_opt with
    |None =>
        (* request is not found in the records *)
        e = {_eventname: "appeal fail"; msg : "the request id is not found"};
        event e
    |Some (SwapRequest swap_id verify_id initial_addr swap_chain initial_money swap_money target_addr swap_chain_initial_addr swap_chain_target_addr state allocator time_lock appeal_ddl) =>
        (* check if the target addr userB *)
        check_target_addr = builtin eq target_addr _sender;
        match check_target_addr with
        | False =>
            e = {_eventname: "appeal fail"; msg : "not the target addr"};
            event e
        | True =>
            (* check if in the appeal window *)
            cur_block_num <- & BLOCKNUMBER;
            check_appeal = builtin blt cur_block_num appeal_ddl;
            match check_appeal with
            | False =>
                e = {_eventname: "appeal fail"; msg : "exceed the appeal ddl"};
                event e
            | True =>
                verify_requests <- req_map;
                verify_request_opt = builtin get verify_requests verify_id;
                match verify_request_opt with
                | None =>
                    e = {_eventname: "appeal fail"; msg : "no transaction hash history"};
                    event e
                | Some (Request verify_request_id from user_addr request_type param_data gas_price gas_limit fee callback_func if_responded) =>
                    (* calculate the accumulated stake *)
                    stakes <- stake_map;
                    stake_opt = builtin get stakes verify_id;
                    match stake_opt with
                    | None =>
                    | Some (Stake from_addr money accumulated_stake) =>
                        accumulated_stake = builtin add accumulated_stake money;
                        money = Uint128 0;
                        update_stake = Stake from_addr money accumulated_stake;
                        stake_map[verify_id] := update_stake;
                        (* set the request state to swap_to_verified *)
                        (* update the time_lock and appeal_ddl *)
                        time_lock = builtin badd time_lock swap_lock;
                        appeal_ddl = builtin badd appeal_ddl appeal_time;
                        update_swap_request = SwapRequest swap_id verify_id initial_addr swap_chain initial_money swap_money target_addr swap_chain_initial_addr swap_chain_target_addr swap_to_verified allocator time_lock appeal_ddl;
                        swap_req_map[swap_id] := update_swap_request;
                        e = {_eventname: "verifyrequest"; msg: "send request success"; id: verify_request_id; from: user_addr; reqtype: request_type; gaslimit: gas_limit; gasprice: gas_price; swapid: swap_id; swapchain: swap_chain; txhash: param_data; initialaddr: swap_chain_initial_addr; targetaddr: swap_chain_initial_addr; swapmoney: swap_money; fee: fee};
                        event e
                    end
                end
            end
        end
    end
end

transition monitor_time_lock()
    (* loop in swap_req_count *)

end
